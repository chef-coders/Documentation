\section{Architektur}\label{sec:architecture}

\subsection{Datenmodell}\label{subsec:datamodel}

Das Datenmodell umfasst drei Klassen: \texttt{Item}, \texttt{User}, \texttt{Purchase}.
Die Klassen sind passend zur bereitgestellten Datenbank implementiert und haben die in Abbildung~\ref{datamodel} gezeigte Struktur.

\cfigure{figures/datamodel.png}{Datenmodell}{\label{datamodel}}

\subsection{Frontend-Architektur}\label{subsec:frontend}
% generelle Architektur (Klassen, verwendete Patterns, Fragments, Activities) und deren grobe Erklärung
Die App nutzt eine Single Activity Architektur und läuft damit hauptsächlich in einer einzigen Activity, der \texttt{MainActivity}.
Durch diese Architektur ergeben sich eine Vielzahl von Vorteilen.

\subsubsection{Aufbau der MainActivity}

Der Aufbau der \texttt{MainActivity} wird in Abbildung~\ref{fig:mainActivityAufbau} dargestellt.
Er besteht aus einem Frame-Layout und einer Toolbar.
Zudem wird durch eine Wisch-Bewegung nach Rechts ein Navigation-Drawer angezeigt.

\subsubsection{Fragmente}

Screens wurden durch Fragmente realisiert.
Dabei handelt es sich um Container, die alle UI-Komponenten des jeweiligen Screens enthalten.
Für jeden Screen, der in Abschnitt~\ref{sec:features} beschrieben wurde, existiert ein solches.
Befindet sich der Benutzer zum Beispiel im Shop-Screen, wird das Shop-Fragment im Frame-Layout angezeigt.
Wechselt der Benutzer zu einem anderen Screen, wird das Fragment im Frame-Layout durch das Fragment des neuen Screens ersetzt.
Dies erfolgt durch Zugriff auf den \texttt{FragmentManager} der \texttt{MainActivity}.

% Vorteile der Fragmente gegenüber Activities

\cfigure{figures/main-activity-aufbau.png}{Aufbau der MainActivity}{\label{fig:mainActivityAufbau}}

\subsubsection{Toolbar}

Im Gegensatz zu den Fragmenten, wird die Toolbar bei Screen-Wechseln nicht ausgetauscht, sondern kann vom neu angezeigten Fragment manipuliert werden.

Die Voraussetzung dafür ist, dass alle Fragments von \texttt{KitchenFragment} erben.
Dieses stellt eine Methode bereit, die aufgerufen wird, sobald das Fragment in der MainActivity angezeigt wird.
Beispielsweise können hier spezielle Symbole des Fragments in der Toolbar angezeigt werden.

Hier zeigt sich ein Vorteil der Single-Activity-Architecture.
Wäre jeder Screen eine eigene Activity, müsste jedes Layout eine eigene Toolbar beinhalten.
Die daraus resultierende Redundanz kann hier vermieden werden, da nur eine Toolbar im Layout der MainActivity benötigt wird.

\subsubsection{Navigation-Drawer}

Durch die Single-Activity-Architektur wird das Benutzen eines Navigation-Drawers erst möglich, da einzig im Layout der MainActivity ein Navigation-Drawer eingebunden werden muss.
Dies führt dazu, dass das Tippen eines Elements im Navigation-Drawer zentral verarbeitet werden kann.
Dadurch kann beispielsweise das Zurückgleiten des Navigation-Drawers nach einem Tipp-Event, sehr einfach erreicht werden.

Im Gegensatz dazu müsste bei der Verwendung vieler Activities, jede Activity ein Navigation-Drawer in deren Layout definieren.
Dies wäre nicht nur redundant, sondern würde auch die Verarbeitung von Tipp-Events und die korrekte Anzeige des Navigation-Drawers weitaus komplexer machen, da mit anderen Activities kommuniziert werden müsste.

\subsubsection{Ausnahmen}

Weil es sich angeboten hat und man sich idealerweise nur einmal anmeldet, ist der Login Screen eine eigene Activity.
Auch der BarcodeScanner ist eine eigene Activity, da die BarcodeScanner Library dies verlangt.

\subsubsection{Kommunikation mit dem Backend-Layer}

Die Architektur ermöglichst sehr einfache Kommunikation mit dem Backend-Layer.
Die MainActivity enthält eine Instanz des \texttt{KitchenManagers}, über den alle UI Elemente, einschließlich der Framgente, mit dem Backend kommunizieren können.
Der genaue Aufbau des \texttt{KitchenManagers} wird in Abschnitt~\ref{subsubsec:access-layer} beschrieben.

\subsubsection{RecyclerViews}

\subsection{Backend-Architektur}\label{subsec:backend}

Die Backend-Architektur besteht aus drei Ebenen (siehe Abbildung~\ref{backendArchitecture}).

\subsubsection{Base-Layer}

Die unterste Ebene bildet die Klasse \texttt{OkHttpConnection}, welche über das Interface \texttt{HttpConnection} implementiert ist.
Die Klasse ist verantwortlich für den primitiven Netzwerkverkehr per HTTP mit beliebigen Inhalten.
Es werden die HTTP-Methoden \texttt{GET}, \texttt{POST}, \texttt{PUT} und \texttt{DELETE} implementiert.
Bei fehlerhaften Anfragen (HTTP-Code $\neq$ 2xx), sowie bei fehlerhaften URLs, wird eine Exception geworfen.

\subsubsection{Abstraction-Layer}

Auf der zweiten Ebene befinden sich die Klassen \texttt{KitchenConnection}, \texttt{LocalDataStore} und \texttt{JsonTranslator}.

\begin{itemize}
	\item  \texttt{KitchenConnection} ist verantwortlich für die spezialisierte Kommunikation mit der bereitgestellten REST-API. Die Klasse enthält Attribute für die Basis-URL des REST-Servers, sowie für Schlüssel zur Erzeugung von Nutzern.
	Alle Funktionen der REST-API werden hier implementiert, indem jede Methode der Klasse einen Pfad der REST-API abdeckt.
	Die Funktionsnamen entsprechen der Spezifikation der REST-API\@.

	\item \texttt{LocalDataStore} ist verantwortlich für das Zwischenspeichern der User, Items und Purchases.
	Dies ermöglicht schnelleren Zugriff auf die jeweiligen Objekte.

	\item \texttt{JsonTranslator} ist verantwortlich für die bidirektionale Umwandlung zwischen Objekten des Datenmodells und JSON-Strings.
	Die verwendete Bibliothek für die Umwandlung ist Google's \texttt{GSON}.
\end{itemize}

\subsubsection{Access-Layer} \label{subsubsec:access-layer}

Die Dritte Ebene beinhaltet nur die Klasse \texttt{KitchenManager}.
Sie ist der Einstiegspunkt des Backend und stellt so alle Operationen zur Verfügung, welche die Oberfläche benötigt.
\texttt{KitchenManager} bildet eine vollständige Abstraktion der REST-API, über die Klasse \texttt{KitchenConnection}, welche bereits die Adressen und benötigten Header der API-Aufrufe abstrahierte.

\cfigure{figures/classStructure.png}{Backend Architektur}{\label{backendArchitecture}}

\subsubsection{Tests}

Alle Backend-Klassen sind durch Unit-, Integrations- und Akzeptanz-Tests ausreichend getestet.
